import { convertSlashes } from "./convertSlashes";
import { findDirectoryWithin, getDirForFilePath, getNameByPath, renameFileInDir } from "./DirectoryManagers";
import { NeutralinoDmFileReader } from "./NeutralinoDmFileReader";
import { path } from "./path";
export class NeutralinoDirectoryManager {
    constructor(path) {
        this.path = path;
        this.name = getNameByPath(path);
    }
    findDirectory(path, options) {
        return findDirectoryWithin(path, this, options);
    }
    async list() {
        const reads = await Neutralino.filesystem.readDirectory(this.path);
        return reads.filter(read => !['.', '..'].includes(read.entry)).map(read => read.entry);
    }
    async listFolders() {
        const reads = await Neutralino.filesystem.readDirectory(this.path);
        return reads.filter(read => !['.', '..'].includes(read.entry) && read.type === 'DIRECTORY')
            .map(read => read.entry);
    }
    async listFiles() {
        const reads = await Neutralino.filesystem.readDirectory(this.path);
        return reads.filter(read => !['.', '..'].includes(read.entry) && read.type !== 'DIRECTORY')
            .map(read => read.entry);
    }
    async getFolders() {
        return Promise.all((await this.listFolders()).map(async (name) => await this.getDirectory(name)));
    }
    async getFiles() {
        const reads = await Neutralino.filesystem.readDirectory(this.path);
        return reads.filter(read => !['.', '..'].includes(read.entry) && read.type !== 'DIRECTORY')
            .map(read => new NeutralinoDmFileReader(this.getFullPath(read.entry), this));
    }
    async createDirectory(newPath) {
        try {
            const fullPath = path.join(this.path, convertSlashes(newPath));
            await Neutralino.filesystem.readDirectory(fullPath);
            // it exists, just read it
            return this.getDirectory(newPath);
        }
        catch (err) {
            if (err.code === 'NE_FS_NOPATHE') {
                const splitPath = convertSlashes(newPath).split('/');
                let pathTo = this.path;
                while (splitPath.length) {
                    const nowName = splitPath.shift();
                    pathTo = path.join(pathTo, nowName);
                    await Neutralino.filesystem.createDirectory(pathTo);
                }
                const fullPath = pathTo; // path.join(this.path, newPath)
                return new NeutralinoDirectoryManager(fullPath);
            }
            throw err;
        }
    }
    async getDirectory(newPath, options) {
        if (!newPath) {
            return this;
        }
        const pathTo = path.join(this.path, newPath);
        try {
            // ensure path exists
            await Neutralino.filesystem.readDirectory(pathTo);
            return new NeutralinoDirectoryManager(pathTo);
        }
        catch (err) {
            if (err.code === 'NE_FS_NOPATHE' && options?.create) {
                return this.createDirectory(newPath);
            }
            throw err; // rethrow
        }
    }
    async findFileByPath(path) {
        const pathSplit = path.split(/\\|\//);
        const fileName = pathSplit.pop().toLowerCase(); // pathSplit[ pathSplit.length-1 ]
        let dir = this;
        // chrome we dig through the first selected directory and search the subs
        if (pathSplit.length) {
            const findDir = await this.findDirectory(pathSplit.join('/'));
            if (!findDir) {
                return;
            }
            dir = findDir;
        }
        const files = await dir.listFiles();
        const matchName = files.find(listName => listName.toLowerCase() === fileName);
        if (!matchName) {
            return;
        }
        const fullPath = dir.getFullPath(matchName);
        return new NeutralinoDmFileReader(fullPath, dir);
    }
    async file(pathTo, options) {
        const existingFile = await this.findFileByPath(pathTo);
        if (existingFile) {
            return existingFile;
        }
        // TODO: This work should most likely only occur if the options.create flag is present otherwise throw not found error
        const dirOptions = { create: options?.create };
        const dir = await getDirForFilePath(pathTo, this, dirOptions);
        const fileName = pathTo.split(/\\|\//).pop();
        const fullPath = path.join(dir.path, fileName);
        return new NeutralinoDmFileReader(fullPath, dir);
    }
    getFullPath(itemPath) {
        let fullFilePath = path.join(this.path, itemPath);
        return convertSlashes(fullFilePath);
    }
    async renameFile(oldFileName, newFileName) {
        return renameFileInDir(oldFileName, newFileName, this);
    }
    async removeEntry(name, options) {
        const split = name.split(/\\|\//);
        const lastName = split.pop(); // remove last item
        const dir = split.length >= 1 ? await this.getDirectory(split.join('/')) : this;
        const pathTo = path.join(dir.path, lastName);
        const fileNames = await dir.listFiles();
        if (fileNames.includes(lastName)) {
            return Neutralino.filesystem.removeFile(pathTo);
        }
        try {
            await Neutralino.filesystem.removeDirectory(pathTo);
        }
        catch (err) {
            // if folder delete failed, it may have items within Neutralino does not have recursive delete
            if (err.code === 'NE_FS_RMDIRER' && options?.recursive) {
                return recurseRemoveDir(await dir.getDirectory(lastName));
            }
            throw err;
        }
        return;
    }
}
async function recurseRemoveDir(dir) {
    // remove all folders within
    const folders = await dir.getFolders();
    for (const subdir of folders) {
        await recurseRemoveDir(subdir);
    }
    // remove all files within
    const list = await dir.listFiles();
    for (const fileName of list) {
        await dir.removeEntry(fileName);
    }
    // try now to delete again
    return Neutralino.filesystem.removeDirectory(dir.path);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmV1dHJhbGlub0RpcmVjdG9yeU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZGlyZWN0b3J5LW1hbmFnZXJzL05ldXRyYWxpbm9EaXJlY3RvcnlNYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQTtBQUNqRCxPQUFPLEVBQW9CLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQTtBQUc5SCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQTtBQUNqRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sUUFBUSxDQUFBO0FBSTdCLE1BQU0sT0FBTywwQkFBMEI7SUFHckMsWUFDUyxJQUFZO1FBQVosU0FBSSxHQUFKLElBQUksQ0FBUTtRQUVuQixJQUFJLENBQUMsSUFBSSxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUNqQyxDQUFDO0lBRUQsYUFBYSxDQUNYLElBQVksRUFDWixPQUF1QztRQUV2QyxPQUFPLG1CQUFtQixDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFvRCxDQUFBO0lBQ3BHLENBQUM7SUFFRCxLQUFLLENBQUMsSUFBSTtRQUNSLE1BQU0sS0FBSyxHQUFHLE1BQU0sVUFBVSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBRSxDQUFBO1FBQ3BFLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUN2RixDQUFDO0lBRUQsS0FB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QUFNLENBQUMsQ0FBQTtTQUNwRDtRQUFDLE9BQU8sR0FBUSxFQUFFO1lBQ2pCLDhGQUE4RjtZQUM5RixJQUFLLEdBQUcsQ0FBQyxJQUFJLEtBQUssZUFBZSxJQUFJLE9BQU8sRUFBRSxTQUFTLEVBQUc7Z0JBQ3hELE9BQU8sZ0JBQWdCLENBQUUsTUFBTSxHQUFHLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFFLENBQUE7YUFDNUQ7WUFDRCxNQUFNLEdBQUcsQ0FBQTtTQUNWO1FBQ0QsT0FBTTtJQUNSLENBQUM7Q0FDRjtBQUVELEtBQUssVUFBVSxnQkFBZ0IsQ0FDN0IsR0FBK0I7SUFFL0IsNEJBQTRCO0lBQzVCLE1BQU0sT0FBTyxHQUFHLE1BQU0sR0FBRyxDQUFDLFVBQVUsRUFBRSxDQUFBO0lBQ3RDLEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxFQUFFO1FBQzVCLE1BQU0sZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUE7S0FDL0I7SUFFRCwwQkFBMEI7SUFDMUIsTUFBTSxJQUFJLEdBQUcsTUFBTSxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUE7SUFDbEMsS0FBSyxNQUFNLFFBQVEsSUFBSSxJQUFJLEVBQUU7UUFDM0IsTUFBTSxHQUFHLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0tBQ2hDO0lBRUQsMEJBQTBCO0lBQzFCLE9BQU8sVUFBVSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUUsR0FBRyxDQUFDLElBQUksQ0FBRSxDQUFBO0FBQzFELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb252ZXJ0U2xhc2hlcyB9IGZyb20gXCIuL2NvbnZlcnRTbGFzaGVzXCJcbmltcG9ydCB7IERpcmVjdG9yeU1hbmFnZXIsIGZpbmREaXJlY3RvcnlXaXRoaW4sIGdldERpckZvckZpbGVQYXRoLCBnZXROYW1lQnlQYXRoLCByZW5hbWVGaWxlSW5EaXIgfSBmcm9tIFwiLi9EaXJlY3RvcnlNYW5hZ2Vyc1wiXG5pbXBvcnQgeyBEbUZpbGVSZWFkZXIgfSBmcm9tIFwiLi9EbUZpbGVSZWFkZXJcIlxuaW1wb3J0IHsgSU5ldXRyYWxpbm8gfSBmcm9tIFwiLi9OZXV0cmFsaW5vLnV0aWxzXCJcbmltcG9ydCB7IE5ldXRyYWxpbm9EbUZpbGVSZWFkZXIgfSBmcm9tIFwiLi9OZXV0cmFsaW5vRG1GaWxlUmVhZGVyXCJcbmltcG9ydCB7IHBhdGggfSBmcm9tIFwiLi9wYXRoXCJcblxuZGVjbGFyZSBjb25zdCBOZXV0cmFsaW5vOiBJTmV1dHJhbGlub1xuXG5leHBvcnQgY2xhc3MgTmV1dHJhbGlub0RpcmVjdG9yeU1hbmFnZXIgaW1wbGVtZW50cyBEaXJlY3RvcnlNYW5hZ2VyIHtcbiAgbmFtZTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHBhdGg6IHN0cmluZyxcbiAgKSB7XG4gICAgdGhpcy5uYW1lID0gZ2V0TmFtZUJ5UGF0aChwYXRoKVxuICB9XG5cbiAgZmluZERpcmVjdG9yeSAoXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBGaWxlU3lzdGVtR2V0RGlyZWN0b3J5T3B0aW9ucyxcbiAgKTogUHJvbWlzZTxOZXV0cmFsaW5vRGlyZWN0b3J5TWFuYWdlciB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiBmaW5kRGlyZWN0b3J5V2l0aGluKHBhdGgsIHRoaXMsIG9wdGlvbnMpIGFzIFByb21pc2U8TmV1dHJhbGlub0RpcmVjdG9yeU1hbmFnZXIgfCB1bmRlZmluZWQ+XG4gIH1cblxuICBhc3luYyBsaXN0KCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCByZWFkcyA9IGF3YWl0IE5ldXRyYWxpbm8uZmlsZXN5c3RlbS5yZWFkRGlyZWN0b3J5KCB0aGlzLnBhdGggKVxuICAgIHJldHVybiByZWFkcy5maWx0ZXIocmVhZCA9PiAhWycuJywnLi4nXS5pbmNsdWRlcyhyZWFkLmVudHJ5KSkubWFwKHJlYWQgPT4gcmVhZC5lbnRyeSlcbiAgfVxuXG4gIGFzeW5jIGxpc3RGb2xkZXJzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCByZWFkcyA9IGF3YWl0IE5ldXRyYWxpbm8uZmlsZXN5c3RlbS5yZWFkRGlyZWN0b3J5KCB0aGlzLnBhdGggKVxuICAgIHJldHVybiByZWFkcy5maWx0ZXIocmVhZCA9PiAhWycuJywnLi4nXS5pbmNsdWRlcyhyZWFkLmVudHJ5KSAmJiByZWFkLnR5cGUgPT09ICdESVJFQ1RPUlknKVxuICAgICAgLm1hcChyZWFkID0+IHJlYWQuZW50cnkpXG4gIH1cblxuICBhc3luYyBsaXN0RmlsZXMoKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHJlYWRzID0gYXdhaXQgTmV1dHJhbGluby5maWxlc3lzdGVtLnJlYWREaXJlY3RvcnkoIHRoaXMucGF0aCApXG4gICAgcmV0dXJuIHJlYWRzLmZpbHRlcihyZWFkID0+ICFbJy4nLCcuLiddLmluY2x1ZGVzKHJlYWQuZW50cnkpICYmIHJlYWQudHlwZSAhPT0gJ0RJUkVDVE9SWScpXG4gICAgICAubWFwKHJlYWQgPT4gcmVhZC5lbnRyeSlcbiAgfVxuXG4gIGFzeW5jIGdldEZvbGRlcnMoKTogUHJvbWlzZTxOZXV0cmFsaW5vRGlyZWN0b3J5TWFuYWdlcltdPiB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgKGF3YWl0IHRoaXMubGlzdEZvbGRlcnMoKSkubWFwKGFzeW5jIG5hbWUgPT4gYXdhaXQgdGhpcy5nZXREaXJlY3RvcnkobmFtZSkpXG4gICAgKVxuICB9XG5cbiAgYXN5bmMgZ2V0RmlsZXMoKTogUHJvbWlzZTxEbUZpbGVSZWFkZXJbXT4ge1xuICAgIGNvbnN0IHJlYWRzID0gYXdhaXQgTmV1dHJhbGluby5maWxlc3lzdGVtLnJlYWREaXJlY3RvcnkoIHRoaXMucGF0aCApXG4gICAgcmV0dXJuIHJlYWRzLmZpbHRlcihyZWFkID0+ICFbJy4nLCcuLiddLmluY2x1ZGVzKHJlYWQuZW50cnkpICYmIHJlYWQudHlwZSAhPT0gJ0RJUkVDVE9SWScpXG4gICAgICAubWFwKHJlYWQgPT4gbmV3IE5ldXRyYWxpbm9EbUZpbGVSZWFkZXIodGhpcy5nZXRGdWxsUGF0aChyZWFkLmVudHJ5KSwgdGhpcykpXG4gIH1cblxuICBhc3luYyBjcmVhdGVEaXJlY3RvcnkoXG4gICAgbmV3UGF0aDogc3RyaW5nXG4gICk6IFByb21pc2U8TmV1dHJhbGlub0RpcmVjdG9yeU1hbmFnZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4odGhpcy5wYXRoLCBjb252ZXJ0U2xhc2hlcyhuZXdQYXRoKSlcbiAgICAgIGF3YWl0IE5ldXRyYWxpbm8uZmlsZXN5c3RlbS5yZWFkRGlyZWN0b3J5KCBmdWxsUGF0aCApXG5cbiAgICAgIC8vIGl0IGV4aXN0cywganVzdCByZWFkIGl0XG4gICAgICByZXR1cm4gdGhpcy5nZXREaXJlY3RvcnkobmV3UGF0aClcbiAgICB9IGNhdGNoKCBlcnI6IGFueSApe1xuICAgICAgaWYgKCBlcnIuY29kZSA9PT0gJ05FX0ZTX05PUEFUSEUnICkge1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSBjb252ZXJ0U2xhc2hlcyhuZXdQYXRoKS5zcGxpdCgnLycpXG4gICAgICAgIGxldCBwYXRoVG8gPSB0aGlzLnBhdGhcbiAgICAgICAgXG4gICAgICAgIHdoaWxlKCBzcGxpdFBhdGgubGVuZ3RoICkge1xuICAgICAgICAgIGNvbnN0IG5vd05hbWUgPSBzcGxpdFBhdGguc2hpZnQoKSBhcyBzdHJpbmdcbiAgICAgICAgICBwYXRoVG8gPSBwYXRoLmpvaW4ocGF0aFRvLCBub3dOYW1lKVxuICAgICAgICAgIGF3YWl0IE5ldXRyYWxpbm8uZmlsZXN5c3RlbS5jcmVhdGVEaXJlY3RvcnkocGF0aFRvKVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aFRvIC8vIHBhdGguam9pbih0aGlzLnBhdGgsIG5ld1BhdGgpXG4gICAgICAgIHJldHVybiBuZXcgTmV1dHJhbGlub0RpcmVjdG9yeU1hbmFnZXIoIGZ1bGxQYXRoICkgICAgXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXREaXJlY3RvcnkoXG4gICAgbmV3UGF0aDogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBGaWxlU3lzdGVtR2V0RGlyZWN0b3J5T3B0aW9uc1xuICApOiBQcm9taXNlPE5ldXRyYWxpbm9EaXJlY3RvcnlNYW5hZ2VyPiB7XG4gICAgaWYgKCAhbmV3UGF0aCApIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHBhdGhUbyA9IHBhdGguam9pbih0aGlzLnBhdGgsIG5ld1BhdGgpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIGVuc3VyZSBwYXRoIGV4aXN0c1xuICAgICAgYXdhaXQgTmV1dHJhbGluby5maWxlc3lzdGVtLnJlYWREaXJlY3RvcnkocGF0aFRvKVxuICAgICAgcmV0dXJuIG5ldyBOZXV0cmFsaW5vRGlyZWN0b3J5TWFuYWdlciggcGF0aFRvIClcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgaWYgKCBlcnIuY29kZSA9PT0gJ05FX0ZTX05PUEFUSEUnICYmIG9wdGlvbnM/LmNyZWF0ZSApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGlyZWN0b3J5KG5ld1BhdGgpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnIgLy8gcmV0aHJvd1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZpbmRGaWxlQnlQYXRoIChcbiAgICBwYXRoOiBzdHJpbmcsXG4gICk6IFByb21pc2U8TmV1dHJhbGlub0RtRmlsZVJlYWRlciB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHBhdGhTcGxpdCA9IHBhdGguc3BsaXQoL1xcXFx8XFwvLylcbiAgICBjb25zdCBmaWxlTmFtZSA9IChwYXRoU3BsaXQucG9wKCkgYXMgc3RyaW5nKS50b0xvd2VyQ2FzZSgpIC8vIHBhdGhTcGxpdFsgcGF0aFNwbGl0Lmxlbmd0aC0xIF1cbiAgICBsZXQgZGlyOiBOZXV0cmFsaW5vRGlyZWN0b3J5TWFuYWdlciA9IHRoaXNcblxuICAgIC8vIGNocm9tZSB3ZSBkaWcgdGhyb3VnaCB0aGUgZmlyc3Qgc2VsZWN0ZWQgZGlyZWN0b3J5IGFuZCBzZWFyY2ggdGhlIHN1YnNcbiAgICBpZiAoIHBhdGhTcGxpdC5sZW5ndGggKSB7XG4gICAgICBjb25zdCBmaW5kRGlyID0gYXdhaXQgdGhpcy5maW5kRGlyZWN0b3J5KCBwYXRoU3BsaXQuam9pbignLycpIClcbiAgICAgIFxuICAgICAgaWYgKCAhZmluZERpciApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBcbiAgICAgIGRpciA9IGZpbmREaXJcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmlsZXMgPSBhd2FpdCBkaXIubGlzdEZpbGVzKClcbiAgICBjb25zdCBtYXRjaE5hbWUgPSBmaWxlcy5maW5kKGxpc3ROYW1lID0+IGxpc3ROYW1lLnRvTG93ZXJDYXNlKCkgPT09IGZpbGVOYW1lKVxuICAgIGlmICggIW1hdGNoTmFtZSApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gZGlyLmdldEZ1bGxQYXRoKG1hdGNoTmFtZSlcbiAgICByZXR1cm4gbmV3IE5ldXRyYWxpbm9EbUZpbGVSZWFkZXIoZnVsbFBhdGgsIGRpcilcbiAgfVxuXG4gIGFzeW5jIGZpbGUoXG4gICAgcGF0aFRvOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IEZpbGVTeXN0ZW1HZXRGaWxlT3B0aW9uc1xuICApIHtcbiAgICBjb25zdCBleGlzdGluZ0ZpbGUgPSBhd2FpdCB0aGlzLmZpbmRGaWxlQnlQYXRoKHBhdGhUbylcblxuICAgIGlmICggZXhpc3RpbmdGaWxlICkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nRmlsZVxuICAgIH1cblxuICAgIC8vIFRPRE86IFRoaXMgd29yayBzaG91bGQgbW9zdCBsaWtlbHkgb25seSBvY2N1ciBpZiB0aGUgb3B0aW9ucy5jcmVhdGUgZmxhZyBpcyBwcmVzZW50IG90aGVyd2lzZSB0aHJvdyBub3QgZm91bmQgZXJyb3JcbiAgICBjb25zdCBkaXJPcHRpb25zID0geyBjcmVhdGU6IG9wdGlvbnM/LmNyZWF0ZSB9XG4gICAgY29uc3QgZGlyID0gYXdhaXQgZ2V0RGlyRm9yRmlsZVBhdGgocGF0aFRvLCB0aGlzLCBkaXJPcHRpb25zKSBhcyBOZXV0cmFsaW5vRGlyZWN0b3J5TWFuYWdlclxuICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aFRvLnNwbGl0KC9cXFxcfFxcLy8pLnBvcCgpIGFzIHN0cmluZ1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKGRpci5wYXRoLCBmaWxlTmFtZSlcblxuICAgIHJldHVybiBuZXcgTmV1dHJhbGlub0RtRmlsZVJlYWRlcihmdWxsUGF0aCwgZGlyKVxuICB9XG5cbiAgZ2V0RnVsbFBhdGgoaXRlbVBhdGg6IHN0cmluZykge1xuICAgIGxldCBmdWxsRmlsZVBhdGggPSBwYXRoLmpvaW4odGhpcy5wYXRoLCBpdGVtUGF0aClcbiAgICByZXR1cm4gY29udmVydFNsYXNoZXMoZnVsbEZpbGVQYXRoKVxuICB9XG5cbiAgYXN5bmMgcmVuYW1lRmlsZShcbiAgICBvbGRGaWxlTmFtZTogc3RyaW5nLFxuICAgIG5ld0ZpbGVOYW1lOiBzdHJpbmdcbiAgKSB7XG4gICAgcmV0dXJuIHJlbmFtZUZpbGVJbkRpcihvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIHRoaXMpXG4gIH1cblxuICBhc3luYyByZW1vdmVFbnRyeShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHsgcmVjdXJzaXZlOiBib29sZWFuIH1cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3BsaXQgPSBuYW1lLnNwbGl0KC9cXFxcfFxcLy8pXG4gICAgY29uc3QgbGFzdE5hbWUgPSBzcGxpdC5wb3AoKSBhcyBzdHJpbmcgLy8gcmVtb3ZlIGxhc3QgaXRlbVxuICAgIGNvbnN0IGRpciA9IHNwbGl0Lmxlbmd0aCA+PSAxID8gYXdhaXQgdGhpcy5nZXREaXJlY3RvcnkoIHNwbGl0LmpvaW4oJy8nKSApIDogdGhpc1xuXG4gICAgY29uc3QgcGF0aFRvID0gcGF0aC5qb2luKGRpci5wYXRoLCBsYXN0TmFtZSlcbiAgICBcbiAgICBjb25zdCBmaWxlTmFtZXMgPSBhd2FpdCBkaXIubGlzdEZpbGVzKClcbiAgICBpZiAoIGZpbGVOYW1lcy5pbmNsdWRlcyhsYXN0TmFtZSkgKSB7XG4gICAgICByZXR1cm4gTmV1dHJhbGluby5maWxlc3lzdGVtLnJlbW92ZUZpbGUocGF0aFRvKVxuICAgIH1cbiAgICAgICAgXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IE5ldXRyYWxpbm8uZmlsZXN5c3RlbS5yZW1vdmVEaXJlY3RvcnkocGF0aFRvKVxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAvLyBpZiBmb2xkZXIgZGVsZXRlIGZhaWxlZCwgaXQgbWF5IGhhdmUgaXRlbXMgd2l0aGluIE5ldXRyYWxpbm8gZG9lcyBub3QgaGF2ZSByZWN1cnNpdmUgZGVsZXRlXG4gICAgICBpZiAoIGVyci5jb2RlID09PSAnTkVfRlNfUk1ESVJFUicgJiYgb3B0aW9ucz8ucmVjdXJzaXZlICkge1xuICAgICAgICByZXR1cm4gcmVjdXJzZVJlbW92ZURpciggYXdhaXQgZGlyLmdldERpcmVjdG9yeShsYXN0TmFtZSkgKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIHJldHVyblxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlY3Vyc2VSZW1vdmVEaXIoXG4gIGRpcjogTmV1dHJhbGlub0RpcmVjdG9yeU1hbmFnZXJcbikge1xuICAvLyByZW1vdmUgYWxsIGZvbGRlcnMgd2l0aGluXG4gIGNvbnN0IGZvbGRlcnMgPSBhd2FpdCBkaXIuZ2V0Rm9sZGVycygpXG4gIGZvciAoY29uc3Qgc3ViZGlyIG9mIGZvbGRlcnMpIHtcbiAgICBhd2FpdCByZWN1cnNlUmVtb3ZlRGlyKHN1YmRpcilcbiAgfVxuXG4gIC8vIHJlbW92ZSBhbGwgZmlsZXMgd2l0aGluXG4gIGNvbnN0IGxpc3QgPSBhd2FpdCBkaXIubGlzdEZpbGVzKClcbiAgZm9yIChjb25zdCBmaWxlTmFtZSBvZiBsaXN0KSB7XG4gICAgYXdhaXQgZGlyLnJlbW92ZUVudHJ5KGZpbGVOYW1lKVxuICB9XG5cbiAgLy8gdHJ5IG5vdyB0byBkZWxldGUgYWdhaW5cbiAgcmV0dXJuIE5ldXRyYWxpbm8uZmlsZXN5c3RlbS5yZW1vdmVEaXJlY3RvcnkoIGRpci5wYXRoIClcbn0iXX0=